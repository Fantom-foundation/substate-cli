package main

import (
	"database/sql"
	"encoding/hex"
	"fmt"
	"github.com/ethereum/go-ethereum/core/vm"
	_ "github.com/mattn/go-sqlite3"
	"log"
)

// Number of records in a SQLITE3 transaction
const MaxNumRecords = 10000

// node structure of a trie
type OpCodeTrie struct {
	frequency  uint64                 // node frequency
	opCode     byte                   // op code
	parent     *OpCodeTrie            // parent node
	transition map[byte]*OpCodeTrie // map
}

// create new trie node (not threadsafe!)
func NewOpCodeTrie() *OpCodeTrie {
	p := new(OpCodeTrie)
	p.transition = make(map[byte]*OpCodeTrie)
	return p
}

// add sequence to OpCodeTrie
func (root *OpCodeTrie) add(seq []byte, frequency uint64) {
	if seq == nil || len(seq) == 0 {
		log.Fatal("Sequence is empty")
	}
	p := root
	root.frequency += frequency
	for i := 0; i < len(seq); i++ {
		op := seq[i]
		new_p, ok := p.transition[op]
		if !ok {
			new_p = NewOpCodeTrie()
			p.transition[op] = new_p
			new_p.parent = p
			new_p.opCode = op
		}
		p = new_p
		p.frequency += frequency
	}
}

// get sequence of a node
func (p OpCodeTrie) get() []byte {
	var (
		stack []*OpCodeTrie
		seq   []byte
	)
	for q := &p; q.parent != nil; q = q.parent {
		stack = append(stack, q)
	}
	for i := len(stack) - 1; i >= 0; i-- {
		seq = append(seq, stack[i].opCode)
	}
	return seq
}

// dump trie
var ctr = 1

func (p OpCodeTrie) dump(db *sql.DB, statement *sql.Stmt) {
	for _, node := range p.transition {
		node.dump(db, statement)
		seq := node.get()
		if len(seq) > 1 {
			bseq := []byte(string(seq))
			// commit dataset when record threshold is reached
			if ctr >= MaxNumRecords {
				ctr = 1
				_, err := db.Exec("END TRANSACTION; BEGIN TRANSACTION;")
				if err != nil {
					log.Fatalln(err.Error())
				}
			} else {
				ctr++
			}
			_, err := statement.Exec(hex.EncodeToString(bseq), node.frequency)
			if err != nil {
				log.Fatalln(err.Error())
			}
		}
	}
}

// Key for a basic-block for frequency measurement
type BasicBlockKey struct {
	Contract     string // contract in hex format
	Instructions string // instructions in hex format
	Address      uint64 // basic-block start address
}

var (
	// basic block frequency generated by micro-profiling
	BasicBlockFrequency = map[BasicBlockKey]uint64{}

	// computed sub-sequences of instructions and their frequencies
	SuperInstructionFrequency = map[string]uint64{}

	// computed op-code frequencies for cross-checking the validity
	OpCodeFrequency = map[byte]uint64{}
)

// read basic block frequency database
func readBasicBlockFrequency() {
	// open sqlite3 database
	db, err := sql.Open("sqlite3", "./basicblocks.db")
	if err != nil {
		log.Fatal(err.Error())
	}
	defer db.Close()
	rows, err := db.Query("SELECT * FROM BasicBlockFrequency;")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	// read from table and populate the JumpDestFrequency map
	ctr := 1
	for rows.Next() {
		var contract string
		var address uint64
		var instructions string
		var frequency uint64
		err = rows.Scan(&contract, &address, &instructions, &frequency)
		BasicBlockFrequency[BasicBlockKey{Contract: contract, Address: address, Instructions: instructions}] = frequency
		if err != nil {
			log.Fatal(err)
		}
		ctr++
	}
}

// compute all super-instructions
func superInstructions() *OpCodeTrie {
	trie := NewOpCodeTrie()
	for bkey, freq := range BasicBlockFrequency {
		// decode the basic block to bytes
		ins, err := hex.DecodeString(bkey.Instructions)
		if err != nil {
			log.Fatal(err)
		}

		// add sequence to trie
		trie.add([]byte(ins),freq)

		// compute op-code frequency (for cross-checking)
		for i := 0; i < len(ins); i++ {
			op := ins[i]
			OpCodeFrequency[op] += freq
		}
	}
	return trie
}

func writeFrequencies(trie *OpCodeTrie) {
	// Dump basic-block frequency statistics into a SQLITE3 database

	// open sqlite3 database
	db, err := sql.Open("sqlite3", "./super-instructions.db") // Open the created SQLite File
	if err != nil {
		log.Fatal(err.Error())
	}
	defer db.Close()

	// switch synchronous mode off, enable memory journaling,
	// and start a new transaction
	_, err = db.Exec("PRAGMA synchronous = OFF;PRAGMA journal_mode = MEMORY")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// drop super-instruction frequency table
	_, err = db.Exec("DROP TABLE IF EXISTS SuperInstructionFrequency;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// create new table
	_, err = db.Exec("CREATE TABLE SuperInstructionFrequency (instructions TEXT, frequency NUMERIC);")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// start a new transaction
	_, err = db.Exec("BEGIN TRANSACTION")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// prepare the insert statement for faster inserts
	statement, err := db.Prepare("INSERT INTO SuperInstructionFrequency (instructions, frequency) VALUES (?, ?)")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// dump trie in database
	trie.dump(db,statement)

	// end transaction
	_, err = db.Exec("END TRANSACTION;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// drop super-instruction frequency table
	_, err = db.Exec("DROP TABLE IF EXISTS OpCodeFrequency;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// create new table
	_, err = db.Exec("CREATE TABLE OpCodeFrequency (opcode TEXT, frequency NUMERIC);")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// begin transaction
	_, err = db.Exec("BEGIN TRANSACTION;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// prepare the insert statement for faster inserts
	statement, err = db.Prepare("INSERT INTO OpCodeFrequency (opcode, frequency) VALUES (?, ?)")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// dump op-code map into database
	for op, freq := range OpCodeFrequency {
		_, err = statement.Exec(vm.OpCode(op).String(), freq)
		if err != nil {
			log.Fatalln(err.Error())
		}
	}

	// end transaction
	_, err = db.Exec("END TRANSACTION;")
	if err != nil {
		log.Fatalln(err.Error())
	}
}

func main() {
	fmt.Printf("Read Basic-Block frequency database ...\n")
	readBasicBlockFrequency()

	fmt.Printf("Compute all super-instruction/op-code frequencies ...\n")
	trie := superInstructions()

	fmt.Printf("Write super-instruction/op-code frequencies ...\n")
	writeFrequencies(trie)

	fmt.Printf("Done.\n")
}
