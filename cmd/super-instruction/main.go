package main

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
	"log"
	"encoding/hex"
	"github.com/ethereum/go-ethereum/core/vm"
)

// Number of records in a SQLITE3 transaction
const MaxNumRecords = 10000

// Key for a basic-block for frequency measurement
type BasicBlockKey struct {
	Contract     string // contract in hex format
	Instructions string // instructions in hex format
	Address      uint64 // basic-block start address
}

var (
	// basic block frequency generated by micro-profiling
	BasicBlockFrequency = map[BasicBlockKey]uint64{}

	// computed sub-sequences of instructions and their frequencies
	SuperInstructionFrequency = map[string]uint64{}

	// computed op-code frequencies for cross-checking the validity
	OpCodeFrequency = map[byte]uint64{}
)

// read basic block frequency database
func readBasicBlockFrequency() {
	// open sqlite3 database
	db, err := sql.Open("sqlite3", "./basicblocks.db")
	if err != nil {
		log.Fatal(err.Error())
	}
	defer db.Close()
	rows, err := db.Query("SELECT * FROM BasicBlockFrequency;")
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	// read from table and populate the JumpDestFrequency map
	ctr := 1
	for rows.Next() {
	 	var contract string
	 	var address uint64
	 	var instructions string
	 	var frequency uint64
		err = rows.Scan(&contract, &address, &instructions, &frequency)
		BasicBlockFrequency[BasicBlockKey{Contract:contract, Address:address, Instructions: instructions}] = frequency
		if err != nil {
			log.Fatal(err)
		}
		ctr++
	}
}

// compute all super-instructions
func superInstructions() {
	for bkey, freq := range BasicBlockFrequency {
		// decode the basic block to bytes
		ins, err := hex.DecodeString(bkey.Instructions)
		if (err != nil) {

			panic("Conversion failed.")
		}

		// compute super-instruction frequency
		// and op-code frequency (as a cross-check)
		for i:=0;i<len(ins);i++ {
			op := ins[i]
			OpCodeFrequency[op] += freq
			for j:=i+2;j<=len(ins);j++ {
				var seq []byte
				copy(seq, ins[i:j])
				SuperInstructionFrequency[hex.EncodeToString(seq)] += freq
			}
		}
	}
}

func writeFrequencies() {
	// Dump basic-block frequency statistics into a SQLITE3 database

	// open sqlite3 database
	db, err := sql.Open("sqlite3", "./super-instructions.db") // Open the created SQLite File
	if err != nil {
		log.Fatal(err.Error())
	}
	defer db.Close()

	// drop super-instruction frequency table
	_, err = db.Exec("DROP TABLE IF EXISTS SuperInstructionFrequency;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// create new table
	_, err = db.Exec("CREATE TABLE SuperInstructionFrequency (instructions TEXT, frequency NUMERIC);")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// switch synchronous mode off, enable memory journaling,
	// and start a new transaction
	_, err = db.Exec("PRAGMA synchronous = OFF;PRAGMA journal_mode = MEMORY;BEGIN TRANSACTION")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// prepare the insert statement for faster inserts
	statement, err := db.Prepare("INSERT INTO SuperInstructionFrequency (instructions, frequency) VALUES (?, ?)")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// populate all values into the DB
	ctr := 1
	for ins, freq := range SuperInstructionFrequency {
		// commit dataset when record threshold is reached
		if ctr >= MaxNumRecords {
			ctr = 1
			_, err = db.Exec("END TRANSACTION; BEGIN TRANSACTION;")
			if err != nil {
				log.Fatalln(err.Error())
			}
		} else {
			ctr++
		}
		_, err = statement.Exec(ins, freq)
		if err != nil {
			log.Fatalln(err.Error())
		}
	}

	// end transaction
	_, err = db.Exec("END TRANSACTION; BEGIN TRANSACTION;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// drop super-instruction frequency table
	_, err = db.Exec("DROP TABLE IF EXISTS OpCodeFrequency;")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// create new table
	_, err = db.Exec("CREATE TABLE OpCodeFrequency (opcode TEXT, frequency NUMERIC);")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// prepare the insert statement for faster inserts
	statement, err = db.Prepare("INSERT INTO OpCodeFrequency (opcode, frequency) VALUES (?, ?)")
	if err != nil {
		log.Fatalln(err.Error())
	}

	// dump op-code map into database
	for op, freq := range OpCodeFrequency {

		_, err = statement.Exec(vm.OpCode(op).String(), freq)
		if err != nil {
			log.Fatalln(err.Error())
		}
	}

	_, err = db.Exec("END TRANSACTION;")
	if err != nil {
		log.Fatalln(err.Error())
	}
}

func main() {
	fmt.Printf("Read Basic-Block frequency database ...\n")
	readBasicBlockFrequency()

	fmt.Printf("Compute all super-instruction/op-code frequencies ...\n")
	superInstructions()

	fmt.Printf("Write super-instruction/op-code frequencies ...\n")
	writeFrequencies() 

	fmt.Printf("Done.\n")
}
