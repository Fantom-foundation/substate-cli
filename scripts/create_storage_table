#!/bin/bash

# Converts a runtime log file of replay to a sqlite3 database
#  The database substate_metrics.db has a table "runtime" containing 
#  contract address and observed runtime measured in nano-seconds.

PROGNAME=$(basename $0)
if [ -z ${DATABASE} ]; then
	DATABASE=/var/data/substate_metrics.db
fi
# run sqlite3 command
#  $1: sqlite3 database filename
#  $2: sqlite3 commmand
function runsql () {
   sqlite3 $1 <<< "$2"
   if [ $? -ne 0 ]
   then
	echo "${PROGNAME}: sqlite3 failed executing $2 on db $1"
	exit 1
   fi
}

# check number of arguments
if [ "$#" -ne 1 ]; then
    echo "${PROGNAME}: specify log-file as single argument."
    exit 1
fi

# check whether log file exists
if [ ! -f "$1" ]; then
   echo "${PROGNAME}: logfile $1 does not exist."
   exit 1
fi


# make a temp file for converting log file to a csv file
TMP_FILE=$(mktemp -q /tmp/runtime.XXXXXX.csv || exit 1)

# set trap to clean up file
trap 'rm -f -- "$TMP_FILE"' EXIT

# Convert log output to a csv file
echo "${PROGNAME}: convert log-file to csv-file..."
grep "^metric" $1 | sed 's/^metric: //' > ${TMP_FILE}
# check whether file exists
if [ ! -f "storage_pre_4564036.csv" ]; then
   echo "${PROGNAME}: warning: storage_pre_4564036.csv does not exist. Output may be inaccurate!"
else
   cat storage_pre_4564036.csv >> ${TMP_FILE}
fi

# Create sqlite3 table (drop old one)
echo "${PROGNAME}: create sqlite3 tables..."
runsql ${DATABASE} "CREATE TABLE IF NOT EXISTS experiment (type TEXT, creation_date TEXT, chainid TEXT, git_date TEXT, git_commit TEXT);"
runsql ${DATABASE} "DROP TABLE IF EXISTS storage_update;"
runsql ${DATABASE} "CREATE TABLE storage_update ( 
			block_number INTEGER NOT NULL, 
			block_timestamp INTEGER NOT NULL, 
			tx_number INTEGER NOT NULL, 
			contract TEXT NOT NULL, 
			storage_update_bytes INTEGER NOT NULL, 
			in_update_size INTEGER NOT NULL, 
			out_update_size TEXT NOT NULL, 
			PRIMARY KEY (block_number, tx_number, contract));"

# Set experiment time
DATE=`date`
CHAIN_ID=`grep "^chain-id:" $1`
GIT_DATE=`grep "^git-date:" $1`
GIT_COMMIT=`grep "^git-commit:" $1`
runsql ${DATABASE} "INSERT INTO experiment VALUES (\"storage\",\"${DATE}\",\"${CHAIN_ID:9}\",\"${GIT_DATE:9}\",\"${GIT_COMMIT:11}\");"

# Load CSV file into sqlite3
echo "${PROGNAME}: import csv-file..."
runsql ${DATABASE} ".mode csv
.import ${TMP_FILE} storage_update"

echo "${PROGNAME}: compute storage size after each transaction..."
runsql ${DATABASE} "DROP TABLE IF EXISTS storage;"
runsql ${DATABASE} "CREATE TABLE storage AS
SELECT
	block_number,
	block_timestamp,
	tx_number,
	contract,
	SUM(storage_update_bytes) OVER (
		PARTITION BY contract
		ORDER BY block_number, tx_number
	)AS storage_bytes,
	storage_update_bytes,
	in_update_size,
	out_update_size
FROM storage_update;"

runsql ${DATABASE} "DROP TABLE IF EXISTS storage_update;"

# error check
echo "${PROGNAME}: find errors in storage table where storage size is smaller than substate update size..."
error_rows=`runsql ${DATABASE} "SELECT COUNT(*) FROM storage WHERE (storage_bytes - out_update_size) < 0 OR (storage_bytes - storage_update_bytes - in_update_size) < 0 limit 10;"`
echo "${PROGNAME}: ${error_rows} error entries found."

# views
echo "${PROGNAME}: create views..."
# account storage
runsql ${DATABASE} "DROP VIEW IF EXISTS v_max_contract_storage;"
runsql ${DATABASE} "CREATE VIEW v_max_contract_storage AS SELECT contract, MAX(storage_bytes) AS storage_bytes FROM storage GROUP BY contract;"

# transaction storage
runsql ${DATABASE} "DROP VIEW IF EXISTS v_transaction_storage;"
runsql ${DATABASE} "CREATE VIEW v_transaction_storage AS 
SELECT 
	block_number, 
	block_timestamp,
	tx_number, 
	SUM(storage_bytes) AS storage_bytes 
FROM storage 
GROUP BY block_number, block_timestamp, tx_number;"

# block storage
runsql ${DATABASE} "DROP VIEW IF EXISTS v_block_storage;"
runsql ${DATABASE} "CREATE VIEW v_block_storage AS 
SELECT
	block_number,
	block_timestamp,
	SUM(storage_bytes) AS storage_bytes
FROM
	(SELECT 
		block_number, 
		block_timestamp,
		contract,
		MAX(storage_bytes) AS storage_bytes
	FROM storage 
	GROUP BY block_number, block_timestamp)
GROUP BY block_number, block_timestamp;"

# blockchain storage
# sum of all contract storage 
runsql ${DATABASE} "DROP VIEW IF EXISTS v_blockchain_storage;"
runsql ${DATABASE} "CREATE VIEW v_blockchain_storage AS SELECT SUM(storage_bytes) AS storage_bytes FROM v_max_contract_storage;"

#
# every 7 days (604800 seconds)
runsql ${DATABASE} "DROP VIEW IF EXISTS v_blockchain_storage_growth;"
runsql ${DATABASE} "CREATE VIEW v_blockchain_storage_growth AS
SELECT
	block_timestamp,
	SUM(storage_update_bytes) OVER (
		ORDER BY block_timestamp
	) AS storage_bytes
FROM
	(SELECT
		(block_timestamp / 604800) * 604800 AS block_timestamp,
		SUM(storage_update_bytes) AS storage_update_bytes
	FROM storage
	GROUP BY (block_timestamp / 604800) * 604800);
"

# remove temporary file
rm -f -- "$TMP_FILE"
trap - EXIT
exit
